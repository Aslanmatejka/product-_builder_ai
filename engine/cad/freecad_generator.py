#!/usr/bin/env python3
"""
FreeCAD Generator - Generate parametric CAD solids from structured JSON constraints
Exports STEP and STL files for manufacturing

Usage: python freecad_generator.py <build_id>
Reads design JSON from stdin, outputs file paths as JSON to stdout
"""

import sys
import json
import os
import math
from pathlib import Path

# FreeCAD imports (conditional for systems without FreeCAD)
try:
    import FreeCAD  # type: ignore
    import Part  # type: ignore
    import Mesh  # type: ignore
    FREECAD_AVAILABLE = True
except ImportError:
    FREECAD_AVAILABLE = False
    print("Warning: FreeCAD not available. Install FreeCAD for actual CAD generation.", file=sys.stderr)


def convert_to_mm(value, units):
    """Convert value to millimeters"""
    if units == 'inches':
        return value * 25.4
    return value


def validate_print_thickness(thickness_mm, material='PLA'):
    """Validate minimum wall thickness for 3D printing"""
    min_thickness = {
        'PLA': 0.8,      # Minimum 0.8mm for PLA
        'PETG': 1.0,     # PETG needs slightly thicker
        'ABS': 1.0,      # ABS similar to PETG
        'TPU': 1.2,      # Flexible material needs more
    }
    min_val = min_thickness.get(material, 0.8)
    
    if thickness_mm < min_val:
        print(f"WARNING: Wall thickness {thickness_mm}mm is below recommended minimum {min_val}mm for {material}", file=sys.stderr)
        print(f"  Increasing to {min_val}mm for printability", file=sys.stderr)
        return min_val
    return thickness_mm


def calculate_print_settings(design_data):
    """Generate recommended 3D print settings based on design"""
    # Get dimensions with safe defaults
    length = design_data.get('length', design_data.get('size', 100))
    width = design_data.get('width', design_data.get('size', 100))
    height = design_data.get('height', design_data.get('size', 50))
    material = design_data.get('material', 'PLA').upper()
    wall_thickness = design_data.get('wall_thickness', 2)
    
    # Calculate volume and surface area for estimates
    volume_cm3 = (length * width * height) / 1000
    
    settings = {
        'material': material,
        'layer_height': 0.2 if height > 30 else 0.1,  # Finer layers for small parts
        'infill_percentage': 20 if wall_thickness >= 2 else 30,  # More infill for thin walls
        'infill_pattern': 'grid',
        'wall_line_count': 3 if wall_thickness >= 2 else 4,  # More perimeters for thin walls
        'top_layers': 4,
        'bottom_layers': 4,
        'print_speed': 50,  # mm/s - conservative for quality
        'support_enabled': False,  # Will be set based on overhang detection
        'support_angle': 50,  # degrees - supports needed below this
        'adhesion_type': 'brim' if volume_cm3 > 50 else 'skirt',  # Brim for larger parts
        'estimated_time_hours': round(volume_cm3 * 0.5, 1),  # Rough estimate
        'estimated_material_g': round(volume_cm3 * 1.25, 1),  # PLA density ~1.24 g/cm³
    }
    
    # Material-specific adjustments
    if material == 'PETG':
        settings['print_speed'] = 40
        settings['adhesion_type'] = 'brim'  # PETG warps more
    elif material == 'ABS':
        settings['print_speed'] = 45
        settings['adhesion_type'] = 'raft'  # ABS warps easily
    elif material == 'TPU':
        settings['print_speed'] = 25  # Flexible materials print slow
        settings['infill_percentage'] = 10  # TPU needs low infill
    
    return settings


def check_manifold_geometry(shape):
    """Check if geometry is manifold (watertight) for 3D printing"""
    try:
        if not shape.isValid():
            print("WARNING: Geometry is not valid - may have errors", file=sys.stderr)
            return False
        
        # Check for closed solid
        if hasattr(shape, 'isClosed') and not shape.isClosed():
            print("WARNING: Geometry is not closed (not watertight)", file=sys.stderr)
            return False
        
        return True
    except Exception as e:
        print(f"WARNING: Could not validate geometry: {e}", file=sys.stderr)
        return False


def export_obj_file(shape, obj_file_path):
    """
    Export FreeCAD shape to OBJ format for visualization
    
    Args:
        shape: FreeCAD Part object
        obj_file_path: Path to output OBJ file
    """
    try:
        # Tessellate the shape to create mesh
        mesh = Mesh.Mesh()
        mesh.addFacets(shape.tessellate(0.1))
        
        # Write OBJ file
        with open(obj_file_path, 'w') as f:
            f.write("# OBJ file generated by Product Builder\n")
            f.write(f"# Vertices: {len(mesh.Topology[0])}\n")
            f.write(f"# Faces: {len(mesh.Topology[1])}\n\n")
            
            # Write vertices
            for vertex in mesh.Topology[0]:
                f.write(f"v {vertex[0]} {vertex[1]} {vertex[2]}\n")
            
            # Write faces (1-indexed)
            for face in mesh.Topology[1]:
                f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")
        
        return True
    except Exception as e:
        print(f"ERROR: Failed to export OBJ: {e}", file=sys.stderr)
        return False


def detect_overhangs(shape, angle_threshold=50):
    """Detect overhanging faces that need support"""
    overhangs = []
    try:
        for face in shape.Faces:
            # Get face normal
            normal = face.normalAt(0.5, 0.5)
            # Calculate angle from vertical (Z-axis)
            z_component = normal.z
            angle_from_vertical = abs(math.degrees(math.acos(min(1.0, max(-1.0, abs(z_component))))))
            
            # If face is more horizontal than threshold, it's an overhang
            if angle_from_vertical > angle_threshold and normal.z < 0:
                overhangs.append({
                    'area': face.Area,
                    'angle': angle_from_vertical,
                    'center': face.CenterOfMass
                })
    except Exception as e:
        print(f"WARNING: Overhang detection failed: {e}", file=sys.stderr)
    
    return overhangs


def add_print_tolerance(dimension, tolerance_type='sliding_fit'):
    """Add appropriate tolerances for 3D printed parts that fit together"""
    tolerances = {
        'tight_fit': 0.1,      # Parts that should be very tight
        'sliding_fit': 0.2,    # Parts that should slide together
        'loose_fit': 0.3,      # Parts with easy assembly
        'clearance': 0.5,      # Parts that need clearance
    }
    return dimension + tolerances.get(tolerance_type, 0.2)


def generate_single_part(part_data, units, doc):
    """Generate a single part shape from part data"""
    shape_type = part_data.get('shape_type', 'box')
    part_name = part_data.get('part_name', part_data.get('name', 'part'))
    
    print(f"  Creating part: {part_name} ({shape_type})", file=sys.stderr)
    
    # Handle cylinder parts
    if shape_type == 'cylinder':
        diameter = convert_to_mm(part_data.get('diameter', 10), units)
        length = convert_to_mm(part_data.get('length', 100), units)
        wall_thickness = convert_to_mm(part_data.get('wall_thickness', 0), units)
        radius = diameter / 2
        
        print(f"    Cylinder: ⌀{diameter}mm x {length}mm", file=sys.stderr)
        
        # Create cylinder
        cylinder = Part.makeCylinder(radius, length)
        
        # Make it hollow if wall thickness specified
        if wall_thickness > 0 and wall_thickness < radius:
            inner_radius = radius - wall_thickness
            inner_length = length - wall_thickness
            if inner_radius > 0 and inner_length > 0:
                inner_cylinder = Part.makeCylinder(inner_radius, inner_length)
                inner_cylinder.translate(FreeCAD.Vector(0, 0, wall_thickness))
                cylinder = cylinder.cut(inner_cylinder)
        
        return cylinder
    
    # Handle box parts
    elif shape_type == 'box':
        length = convert_to_mm(part_data.get('length', 100), units)
        width = convert_to_mm(part_data.get('width', 100), units)
        height = convert_to_mm(part_data.get('height', 100), units)
        wall_thickness = convert_to_mm(part_data.get('wall_thickness', 0), units)
        
        print(f"    Box: {length}x{width}x{height}mm", file=sys.stderr)
        
        box = Part.makeBox(length, width, height)
        
        # Make it hollow if wall thickness specified
        if wall_thickness > 0 and wall_thickness < min(length, width, height) / 2:
            inner_length = length - 2 * wall_thickness
            inner_width = width - 2 * wall_thickness
            inner_height = height - wall_thickness
            
            if inner_length > 0 and inner_width > 0 and inner_height > 0:
                inner_box = Part.makeBox(inner_length, inner_width, inner_height)
                inner_box.translate(FreeCAD.Vector(wall_thickness, wall_thickness, wall_thickness))
                box = box.cut(inner_box)
        
        return box
    
    # Handle sphere parts
    elif shape_type == 'sphere':
        diameter = convert_to_mm(part_data.get('diameter', 50), units)
        radius = diameter / 2
        
        print(f"    Sphere: ⌀{diameter}mm", file=sys.stderr)
        return Part.makeSphere(radius)
    
    # Fallback to box
    else:
        print(f"    Warning: Unknown shape_type '{shape_type}', using box", file=sys.stderr)
        length = convert_to_mm(part_data.get('length', 100), units)
        width = convert_to_mm(part_data.get('width', length), units)
        height = convert_to_mm(part_data.get('height', length), units)
        return Part.makeBox(length, width, height)


def generate_assembly(design_data, output_dir, build_id):
    """Generate an assembly with multiple parts"""
    
    if not FREECAD_AVAILABLE:
        raise RuntimeError("FreeCAD is not available")
    
    # Create FreeCAD document
    doc = FreeCAD.newDocument(f"Assembly_{build_id}")
    
    units = design_data.get('units', 'mm')
    parts = design_data.get('parts', [])
    product_type = design_data.get('product_type', 'assembly')
    
    print(f"Generating assembly: {product_type} with {len(parts)} parts", file=sys.stderr)
    
    # Generate each part
    generated_parts = []
    for i, part in enumerate(parts):
        try:
            part_name = part.get('part_name', part.get('name', f'part_{i+1}'))
            shape = generate_single_part(part, units, doc)
            
            # Add to document
            part_obj = doc.addObject("Part::Feature", part_name)
            part_obj.Shape = shape
            
            # Apply position if specified
            if 'position' in part:
                pos = part['position']
                x = convert_to_mm(pos.get('x', 0), units)
                y = convert_to_mm(pos.get('y', 0), units)
                z = convert_to_mm(pos.get('z', 0), units)
                part_obj.Placement.Base = FreeCAD.Vector(x, y, z)
            
            # Apply rotation if specified
            if 'rotation' in part:
                rot = part['rotation']
                if 'axis' in rot and 'angle' in rot:
                    axis = rot['axis']
                    angle = rot['angle']
                    part_obj.Placement.Rotation = FreeCAD.Rotation(
                        FreeCAD.Vector(axis['x'], axis['y'], axis['z']),
                        angle
                    )
            
            generated_parts.append(part_obj)
            print(f"    ✓ Created {part_name}", file=sys.stderr)
            
        except Exception as e:
            print(f"    ✗ Failed to create part {i+1}: {e}", file=sys.stderr)
            import traceback
            traceback.print_exc(file=sys.stderr)
    
    # Export files
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    exported_files = []
    
    # Export as single assembly STEP file
    step_file = output_dir / f"{build_id}.step"
    try:
        Part.export(generated_parts, str(step_file))
        print(f"Exported assembly STEP: {step_file.name}", file=sys.stderr)
        exported_files.append(str(step_file.name))
    except Exception as e:
        print(f"Error exporting assembly STEP: {e}", file=sys.stderr)
    
    # Export as STL (combine all parts)
    stl_file = output_dir / f"{build_id}.stl"
    try:
        import MeshPart
        # Combine all shapes
        combined_shape = generated_parts[0].Shape
        for part_obj in generated_parts[1:]:
            combined_shape = combined_shape.fuse(part_obj.Shape)
        
        mesh = MeshPart.meshFromShape(
            combined_shape,
            LinearDeflection=0.1,
            AngularDeflection=0.523599,
            Relative=False
        )
        mesh.write(str(stl_file))
        print(f"Exported assembly STL: {stl_file.name}", file=sys.stderr)
        exported_files.append(str(stl_file.name))
    except Exception as e:
        print(f"Error exporting assembly STL: {e}", file=sys.stderr)
    
    # Also export individual parts
    for i, (part, part_obj) in enumerate(zip(parts, generated_parts)):
        part_name = part.get('part_name', part.get('name', f'part_{i+1}'))
        
        # Export individual STEP files
        part_step_file = output_dir / f"{build_id}_part{i+1}_{part_name}.step"
        try:
            Part.export([part_obj], str(part_step_file))
            print(f"  Exported part {i+1} STEP: {part_step_file.name}", file=sys.stderr)
            exported_files.append(str(part_step_file.name))
        except Exception as e:
            print(f"  Error exporting part {i+1} STEP: {e}", file=sys.stderr)
    
    # Close document
    FreeCAD.closeDocument(doc.Name)
    
    return exported_files


def generate_cad_model(design_data, output_dir, build_id):
    """Generate CAD model from design constraints"""
    
    if not FREECAD_AVAILABLE:
        raise RuntimeError(
            "FreeCAD is not installed or not available in Python path. "
            "Please install FreeCAD to generate CAD models. "
            "See docs/INSTALL_CAD_TOOLS.md for installation instructions."
        )
    
    # Check if this is an assembly
    is_assembly = design_data.get('is_assembly', False)
    parts = design_data.get('parts', [])
    
    if is_assembly and parts:
        print(f"Assembly mode detected: {len(parts)} parts", file=sys.stderr)
        return generate_assembly(design_data, output_dir, build_id)
    
    # Create FreeCAD document
    doc = FreeCAD.newDocument(f"Build_{build_id}")
    
    # Convert dimensions to mm (FreeCAD default)
    units = design_data.get('units', 'mm')
    
    # Get dimensions with safe defaults (handle cases where dimensions might not exist)
    length = convert_to_mm(design_data.get('length', design_data.get('size', 100)), units)
    width = convert_to_mm(design_data.get('width', design_data.get('size', 100)), units)
    height = convert_to_mm(design_data.get('height', design_data.get('size', 100)), units)
    wall_thickness_raw = convert_to_mm(design_data.get('wall_thickness', 2), units)
    
    # Validate and adjust wall thickness for 3D printing
    material = design_data.get('material', 'PLA')
    wall_thickness = validate_print_thickness(wall_thickness_raw, material)
    
    # Add tolerances for parts that fit together
    has_assembly = any(f in str(design_data.get('features', [])) for f in ['snap', 'lid', 'clip', 'fit'])
    if has_assembly:
        print(f"Detected assembly features - applying fit tolerances", file=sys.stderr)
    
    product_type = design_data.get('product_type', 'enclosure')
    shape_type = design_data.get('shape_type', 'box')
    
    print(f"Generating {product_type} ({shape_type})...", file=sys.stderr)
    
    # Create base shape based on shape_type
    if shape_type == 'cylinder':
        diameter = convert_to_mm(design_data.get('diameter', width), units)
        radius = diameter / 2
        cylinder_length = length
        print(f"Cylinder: ⌀{diameter}mm x {cylinder_length}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(radius, cylinder_length)
        if wall_thickness > 0 and wall_thickness < radius:
            inner_radius = radius - wall_thickness
            inner_length = cylinder_length - wall_thickness
            if inner_radius > 0 and inner_length > 0:
                inner_cylinder = Part.makeCylinder(inner_radius, inner_length)
                inner_cylinder.translate(FreeCAD.Vector(0, 0, wall_thickness))
                outer_box = outer_box.cut(inner_cylinder)
                
    elif shape_type == 'sphere':
        diameter = convert_to_mm(design_data.get('diameter', max(length, width, height)), units)
        radius = diameter / 2
        print(f"Sphere: ⌀{diameter}mm", file=sys.stderr)
        outer_box = Part.makeSphere(radius)
        if wall_thickness > 0 and wall_thickness < radius:
            inner_radius = radius - wall_thickness
            if inner_radius > 0:
                inner_sphere = Part.makeSphere(inner_radius)
                outer_box = outer_box.cut(inner_sphere)
                
    elif shape_type == 'cone':
        diameter_base = convert_to_mm(design_data.get('diameter_base', width), units)
        radius_base = diameter_base / 2
        cone_height = convert_to_mm(design_data.get('height', height), units)
        print(f"Cone: ⌀{diameter_base}mm base x {cone_height}mm height", file=sys.stderr)
        outer_box = Part.makeCone(0, radius_base, cone_height)
        if wall_thickness > 0:
            inner_radius = radius_base - wall_thickness
            inner_height = cone_height - wall_thickness
            if inner_radius > 0 and inner_height > 0:
                inner_cone = Part.makeCone(0, inner_radius, inner_height)
                inner_cone.translate(FreeCAD.Vector(0, 0, wall_thickness))
                outer_box = outer_box.cut(inner_cone)
                
    elif shape_type == 'torus':
        major_diameter = convert_to_mm(design_data.get('major_diameter', max(length, width)), units)
        minor_diameter = convert_to_mm(design_data.get('minor_diameter', height), units)
        major_radius = major_diameter / 2
        minor_radius = minor_diameter / 2
        print(f"Torus: major ⌀{major_diameter}mm, minor ⌀{minor_diameter}mm", file=sys.stderr)
        outer_box = Part.makeTorus(major_radius, minor_radius)
        
    elif shape_type == 'pyramid':
        base_width = convert_to_mm(design_data.get('base_width', width), units)
        pyramid_height = convert_to_mm(design_data.get('height', height), units)
        print(f"Pyramid: base {base_width}mm x {pyramid_height}mm height", file=sys.stderr)
        # Create pyramid using cone with square base approximation
        outer_box = Part.makeCone(0, base_width/1.414, pyramid_height)
        
    elif shape_type == 'dome':
        diameter = convert_to_mm(design_data.get('diameter', max(length, width)), units)
        radius = diameter / 2
        print(f"Dome (hemisphere): ⌀{diameter}mm", file=sys.stderr)
        sphere = Part.makeSphere(radius)
        # Cut sphere in half to make dome
        cut_box = Part.makeBox(radius*2, radius*2, radius)
        cut_box.translate(FreeCAD.Vector(-radius, -radius, -radius))
        outer_box = sphere.cut(cut_box)
        if wall_thickness > 0 and wall_thickness < radius:
            inner_radius = radius - wall_thickness
            inner_sphere = Part.makeSphere(inner_radius)
            outer_box = outer_box.cut(inner_sphere)
            
    elif shape_type == 'prism':
        diameter = convert_to_mm(design_data.get('diameter', width), units)
        prism_height = convert_to_mm(design_data.get('height', height), units)
        sides = design_data.get('sides', 6)  # Default hexagon
        print(f"Prism: {sides}-sided, ⌀{diameter}mm x {prism_height}mm", file=sys.stderr)
        radius = diameter / 2
        points = []
        for i in range(sides):
            angle = 2 * math.pi * i / sides
            x = radius * math.cos(angle)
            y = radius * math.sin(angle)
            points.append(FreeCAD.Vector(x, y, 0))
        points.append(points[0])
        polygon = Part.makePolygon(points)
        face = Part.Face(polygon)
        outer_box = face.extrude(FreeCAD.Vector(0, 0, prism_height))
        if wall_thickness > 0:
            inner_radius = radius - wall_thickness
            inner_points = []
            for i in range(sides):
                angle = 2 * math.pi * i / sides
                x = inner_radius * math.cos(angle)
                y = inner_radius * math.sin(angle)
                inner_points.append(FreeCAD.Vector(x, y, wall_thickness))
            inner_points.append(inner_points[0])
            inner_polygon = Part.makePolygon(inner_points)
            inner_face = Part.Face(inner_polygon)
            inner_prism = inner_face.extrude(FreeCAD.Vector(0, 0, prism_height - wall_thickness))
            outer_box = outer_box.cut(inner_prism)
            
    elif shape_type == 'screw':
        thread_specs = {'M3': 3, 'M4': 4, 'M5': 5, 'M6': 6, 'M8': 8}
        thread_size = design_data.get('thread_size', 'M3')
        screw_diameter = thread_specs.get(thread_size, 3)
        screw_length = convert_to_mm(design_data.get('length', length), units)
        head_diameter = screw_diameter * 1.8
        head_height = screw_diameter * 0.6
        print(f"Screw: {thread_size} x {screw_length}mm", file=sys.stderr)
        head = Part.makeCylinder(head_diameter/2, head_height)
        shaft = Part.makeCylinder(screw_diameter/2, screw_length)
        shaft.translate(FreeCAD.Vector(0, 0, -screw_length))
        outer_box = head.fuse(shaft)
        
    elif shape_type == 'nut':
        thread_specs = {'M3': 3, 'M4': 4, 'M5': 5, 'M6': 6, 'M8': 8}
        thread_size = design_data.get('thread_size', 'M3')
        nut_diameter = thread_specs.get(thread_size, 3) * 1.8
        nut_height = thread_specs.get(thread_size, 3) * 0.8
        hole_diameter = thread_specs.get(thread_size, 3)
        print(f"Hex Nut: {thread_size}", file=sys.stderr)
        points = []
        for i in range(6):
            angle = 2 * math.pi * i / 6
            x = (nut_diameter/2) * math.cos(angle)
            y = (nut_diameter/2) * math.sin(angle)
            points.append(FreeCAD.Vector(x, y, 0))
        points.append(points[0])
        hex_shape = Part.makePolygon(points)
        hex_face = Part.Face(hex_shape)
        outer_box = hex_face.extrude(FreeCAD.Vector(0, 0, nut_height))
        hole = Part.makeCylinder(hole_diameter/2, nut_height * 1.1)
        hole.translate(FreeCAD.Vector(0, 0, -0.05 * nut_height))
        outer_box = outer_box.cut(hole)
        
    elif shape_type == 'gear':
        teeth = design_data.get('teeth_count', 20)
        module = design_data.get('module', 2)
        gear_thickness = convert_to_mm(design_data.get('thickness', 5), units)
        bore = convert_to_mm(design_data.get('bore_diameter', 6), units)
        pitch_diameter = teeth * module
        print(f"Spur Gear: {teeth} teeth, module {module}, ⌀{pitch_diameter}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(pitch_diameter/2, gear_thickness)
        if bore > 0:
            bore_hole = Part.makeCylinder(bore/2, gear_thickness * 1.1)
            bore_hole.translate(FreeCAD.Vector(0, 0, -0.05 * gear_thickness))
            outer_box = outer_box.cut(bore_hole)
            
    elif shape_type == 'pulley':
        pulley_diameter = convert_to_mm(design_data.get('diameter', width), units)
        pulley_width = convert_to_mm(design_data.get('width', height), units)
        bore = convert_to_mm(design_data.get('bore_diameter', 6), units)
        grooves = design_data.get('groove_count', 1)
        print(f"Pulley: ⌀{pulley_diameter}mm x {pulley_width}mm, {grooves} grooves", file=sys.stderr)
        outer_box = Part.makeCylinder(pulley_diameter/2, pulley_width)
        if bore > 0:
            bore_hole = Part.makeCylinder(bore/2, pulley_width * 1.1)
            bore_hole.translate(FreeCAD.Vector(0, 0, -0.05 * pulley_width))
            outer_box = outer_box.cut(bore_hole)
            
    elif shape_type == 'washer':
        inner_d = convert_to_mm(design_data.get('inner_diameter', 3), units)
        outer_d = convert_to_mm(design_data.get('outer_diameter', 7), units)
        washer_thickness = convert_to_mm(design_data.get('thickness', 0.8), units)
        print(f"Washer: ⌀{outer_d}mm/⌀{inner_d}mm x {washer_thickness}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(outer_d/2, washer_thickness)
        hole = Part.makeCylinder(inner_d/2, washer_thickness * 1.1)
        hole.translate(FreeCAD.Vector(0, 0, -0.05 * washer_thickness))
        outer_box = outer_box.cut(hole)
        
    elif shape_type == 'bearing':
        bore = convert_to_mm(design_data.get('bore_diameter', 8), units)
        outer_d = convert_to_mm(design_data.get('outer_diameter', 22), units)
        bearing_width = convert_to_mm(design_data.get('width', 7), units)
        print(f"Bearing: ⌀{outer_d}mm/⌀{bore}mm x {bearing_width}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(outer_d/2, bearing_width)
        inner_hole = Part.makeCylinder(bore/2, bearing_width * 1.1)
        inner_hole.translate(FreeCAD.Vector(0, 0, -0.05 * bearing_width))
        outer_box = outer_box.cut(inner_hole)
        
    elif shape_type == 'shaft':
        shaft_diameter = convert_to_mm(design_data.get('diameter', width), units)
        shaft_length = convert_to_mm(design_data.get('length', length), units)
        print(f"Shaft: ⌀{shaft_diameter}mm x {shaft_length}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(shaft_diameter/2, shaft_length)
        
    elif shape_type == 'spring':
        coil_diameter = convert_to_mm(design_data.get('diameter', 10), units)
        wire_d = convert_to_mm(design_data.get('wire_diameter', 1), units)
        num_coils = design_data.get('coils', 10)
        spring_length = convert_to_mm(design_data.get('length', 50), units)
        print(f"Spring: ⌀{coil_diameter}mm, {num_coils} coils, {spring_length}mm", file=sys.stderr)
        pitch = spring_length / num_coils
        helix = Part.makeHelix(pitch, spring_length, coil_diameter/2)
        wire_circle = Part.Wire(Part.makeCircle(wire_d/2, FreeCAD.Vector(coil_diameter/2, 0, 0)))
        outer_box = wire_circle.makePipeShell([helix], True, False)
        
    elif shape_type == 'knob':
        knob_diameter = convert_to_mm(design_data.get('diameter', 20), units)
        knob_height = convert_to_mm(design_data.get('height', 15), units)
        shaft_d = convert_to_mm(design_data.get('shaft_diameter', 6), units)
        print(f"Knob: ⌀{knob_diameter}mm x {knob_height}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(knob_diameter/2, knob_height)
        shaft_hole = Part.makeCylinder(shaft_d/2, knob_height * 1.1)
        shaft_hole.translate(FreeCAD.Vector(0, 0, -0.05 * knob_height))
        outer_box = outer_box.cut(shaft_hole)
        
    elif shape_type == 'hinge':
        hinge_length = convert_to_mm(design_data.get('length', 50), units)
        hinge_width = convert_to_mm(design_data.get('width', 15), units)
        barrel_d = convert_to_mm(design_data.get('barrel_diameter', 5), units)
        print(f"Hinge: {hinge_length}mm x {hinge_width}mm", file=sys.stderr)
        leaf1 = Part.makeBox(hinge_width/2, hinge_length, 2)
        leaf2 = Part.makeBox(hinge_width/2, hinge_length, 2)
        leaf2.translate(FreeCAD.Vector(hinge_width/2 + barrel_d, 0, 0))
        barrel = Part.makeCylinder(barrel_d/2, hinge_length)
        barrel.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(1, 0, 0), 90)
        barrel.translate(FreeCAD.Vector(hinge_width/2, 0, 0))
        outer_box = leaf1.fuse(leaf2).fuse(barrel)
        
    elif shape_type == 'phone_case':
        phone_specs = {
            'iPhone 14': (71.5, 146.7, 7.8),
            'iPhone 15': (71.6, 147.6, 7.8),
            'Samsung S23': (70.9, 146.3, 7.6),
            'Pixel 8': (70.8, 150.5, 8.9)
        }
        phone_model = design_data.get('phone_model', 'custom')
        if phone_model in phone_specs:
            case_width, case_length, case_height = phone_specs[phone_model]
        else:
            case_width = convert_to_mm(design_data.get('width', 75), units)
            case_length = convert_to_mm(design_data.get('length', 150), units)
            case_height = convert_to_mm(design_data.get('height', 10), units)
        clearance = 0.5
        print(f"Phone Case: {phone_model if phone_model != 'custom' else 'custom'} ({case_width}x{case_length}x{case_height}mm)", file=sys.stderr)
        outer = Part.makeBox(case_width + 2*wall_thickness, case_length + 2*wall_thickness, case_height + wall_thickness)
        inner = Part.makeBox(case_width + clearance, case_length + clearance, case_height + clearance)
        inner.translate(FreeCAD.Vector(wall_thickness, wall_thickness, wall_thickness))
        outer_box = outer.cut(inner)
        
    elif shape_type == 'bottle':
        bottle_diameter = convert_to_mm(design_data.get('diameter', 70), units)
        bottle_height = convert_to_mm(design_data.get('height', 200), units)
        neck_d = convert_to_mm(design_data.get('neck_diameter', 30), units)
        neck_height = bottle_height * 0.15
        print(f"Bottle: ⌀{bottle_diameter}mm x {bottle_height}mm", file=sys.stderr)
        body = Part.makeCylinder(bottle_diameter/2, bottle_height - neck_height)
        neck = Part.makeCylinder(neck_d/2, neck_height)
        neck.translate(FreeCAD.Vector(0, 0, bottle_height - neck_height))
        outer_box = body.fuse(neck)
        if wall_thickness > 0:
            inner_body = Part.makeCylinder(bottle_diameter/2 - wall_thickness, bottle_height - neck_height - wall_thickness)
            inner_body.translate(FreeCAD.Vector(0, 0, wall_thickness))
            outer_box = outer_box.cut(inner_body)
            
    elif shape_type == 'cup':
        cup_diameter = convert_to_mm(design_data.get('diameter', 80), units)
        cup_height = convert_to_mm(design_data.get('height', 100), units)
        has_handle = design_data.get('handle', True)
        print(f"Cup: ⌀{cup_diameter}mm x {cup_height}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(cup_diameter/2, cup_height)
        if wall_thickness > 0:
            inner = Part.makeCylinder(cup_diameter/2 - wall_thickness, cup_height - wall_thickness)
            inner.translate(FreeCAD.Vector(0, 0, wall_thickness))
            outer_box = outer_box.cut(inner)
        if has_handle:
            handle = Part.makeTorus(15, 5)
            handle.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 1, 0), 90)
            handle.translate(FreeCAD.Vector(cup_diameter/2, 0, cup_height * 0.6))
            outer_box = outer_box.fuse(handle)
            
    elif shape_type == 'vase':
        base_d = convert_to_mm(design_data.get('base_diameter', 60), units)
        top_d = convert_to_mm(design_data.get('top_diameter', 80), units)
        vase_height = convert_to_mm(design_data.get('height', 150), units)
        print(f"Vase: ⌀{base_d}mm base, ⌀{top_d}mm top, {vase_height}mm", file=sys.stderr)
        outer_box = Part.makeCone(base_d/2, top_d/2, vase_height)
        if wall_thickness > 0:
            inner = Part.makeCone(base_d/2 - wall_thickness, top_d/2 - wall_thickness, vase_height - wall_thickness)
            inner.translate(FreeCAD.Vector(0, 0, wall_thickness))
            outer_box = outer_box.cut(inner)
            
    elif shape_type == 'bowl':
        bowl_diameter = convert_to_mm(design_data.get('diameter', 120), units)
        bowl_depth = convert_to_mm(design_data.get('depth', 50), units)
        print(f"Bowl: ⌀{bowl_diameter}mm x {bowl_depth}mm deep", file=sys.stderr)
        outer_sphere = Part.makeSphere(bowl_diameter/2)
        cut_box = Part.makeBox(bowl_diameter, bowl_diameter, bowl_diameter/2)
        cut_box.translate(FreeCAD.Vector(-bowl_diameter/2, -bowl_diameter/2, -bowl_diameter/2))
        outer_box = outer_sphere.cut(cut_box)
        if wall_thickness > 0:
            inner_sphere = Part.makeSphere(bowl_diameter/2 - wall_thickness)
            outer_box = outer_box.cut(inner_sphere)
            
    elif shape_type == 'plate':
        plate_diameter = convert_to_mm(design_data.get('diameter', 200), units)
        plate_depth = convert_to_mm(design_data.get('depth', 20), units)
        rim_width = convert_to_mm(design_data.get('rim_width', 15), units)
        print(f"Plate: ⌀{plate_diameter}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(plate_diameter/2, plate_depth)
        center_depth = Part.makeCylinder(plate_diameter/2 - rim_width, plate_depth - wall_thickness)
        center_depth.translate(FreeCAD.Vector(0, 0, wall_thickness))
        outer_box = outer_box.cut(center_depth)
        
    elif shape_type == 'pen_holder':
        holder_diameter = convert_to_mm(design_data.get('diameter', 80), units)
        holder_height = convert_to_mm(design_data.get('height', 100), units)
        compartments = design_data.get('compartments', 1)
        print(f"Pen Holder: ⌀{holder_diameter}mm x {holder_height}mm, {compartments} compartments", file=sys.stderr)
        outer_box = Part.makeCylinder(holder_diameter/2, holder_height)
        inner = Part.makeCylinder(holder_diameter/2 - wall_thickness, holder_height - wall_thickness)
        inner.translate(FreeCAD.Vector(0, 0, wall_thickness))
        outer_box = outer_box.cut(inner)
        
    elif shape_type == 'cable_organizer':
        organizer_length = convert_to_mm(design_data.get('length', 100), units)
        organizer_width = convert_to_mm(design_data.get('width', 50), units)
        slots = design_data.get('slots', 3)
        slot_width = organizer_width / (slots + 1)
        print(f"Cable Organizer: {organizer_length}x{organizer_width}mm, {slots} slots", file=sys.stderr)
        base = Part.makeBox(organizer_length, organizer_width, wall_thickness * 2)
        outer_box = base
        for i in range(slots):
            slot = Part.makeCylinder(5, organizer_length)
            slot.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 1, 0), 90)
            slot.translate(FreeCAD.Vector(0, slot_width * (i + 1), wall_thickness * 2))
            outer_box = outer_box.fuse(Part.makeCylinder(7, wall_thickness * 4).translate(FreeCAD.Vector(0, slot_width * (i + 1), 0)))
            
    elif shape_type == 'card_holder':
        card_w = convert_to_mm(design_data.get('card_width', 85), units)
        card_h = convert_to_mm(design_data.get('card_height', 55), units)
        slots = design_data.get('slots', 1)
        print(f"Card Holder: {card_w}x{card_h}mm, {slots} slots", file=sys.stderr)
        slot_thickness = 1.5
        base = Part.makeBox(card_w + 4, card_h/2 + 2, (slot_thickness + 0.5) * slots + wall_thickness * 2)
        outer_box = base
        for i in range(slots):
            slot = Part.makeBox(card_w, card_h/2, slot_thickness)
            slot.translate(FreeCAD.Vector(2, 1, wall_thickness + i * (slot_thickness + 0.5)))
            outer_box = outer_box.cut(slot)
            
    elif shape_type == 'phone_stand':
        angle = design_data.get('angle', 60)
        slot_w = convert_to_mm(design_data.get('slot_width', 12), units)
        base_len = convert_to_mm(design_data.get('base_length', 80), units)
        print(f"Phone Stand: {angle}° angle, {base_len}mm base", file=sys.stderr)
        base = Part.makeBox(base_len, 70, 5)
        back = Part.makeBox(5, 70, 60)
        back.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 1, 0), angle - 90)
        back.translate(FreeCAD.Vector(base_len - 20, 0, 5))
        outer_box = base.fuse(back)
        
    elif shape_type == 'coaster':
        coaster_diameter = convert_to_mm(design_data.get('diameter', 95), units)
        coaster_thickness = convert_to_mm(design_data.get('thickness', 3), units)
        print(f"Coaster: ⌀{coaster_diameter}mm x {coaster_thickness}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(coaster_diameter/2, coaster_thickness)
        
    elif shape_type == 'keychain':
        keychain_length = convert_to_mm(design_data.get('length', 40), units)
        keychain_width = convert_to_mm(design_data.get('width', 25), units)
        keychain_thickness = convert_to_mm(design_data.get('thickness', 3), units)
        ring_d = convert_to_mm(design_data.get('ring_diameter', 8), units)
        print(f"Keychain: {keychain_length}x{keychain_width}x{keychain_thickness}mm", file=sys.stderr)
        body = Part.makeBox(keychain_length, keychain_width, keychain_thickness)
        ring = Part.makeTorus(ring_d/2, 1)
        ring.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 1, 0), 90)
        ring.translate(FreeCAD.Vector(0, keychain_width/2, keychain_thickness/2))
        outer_box = body.fuse(ring)
        
    elif shape_type == 'planter':
        planter_diameter = convert_to_mm(design_data.get('diameter', 100), units)
        planter_height = convert_to_mm(design_data.get('height', 80), units)
        drainage = design_data.get('drainage', True)
        print(f"Planter: ⌀{planter_diameter}mm x {planter_height}mm", file=sys.stderr)
        outer_box = Part.makeCylinder(planter_diameter/2, planter_height)
        inner = Part.makeCylinder(planter_diameter/2 - wall_thickness, planter_height - wall_thickness)
        inner.translate(FreeCAD.Vector(0, 0, wall_thickness))
        outer_box = outer_box.cut(inner)
        if drainage:
            drain_holes = [Part.makeCylinder(3, wall_thickness * 2) for _ in range(4)]
            for i, hole in enumerate(drain_holes):
                angle = i * math.pi / 2
                x = (planter_diameter/3) * math.cos(angle)
                y = (planter_diameter/3) * math.sin(angle)
                hole.translate(FreeCAD.Vector(x, y, -wall_thickness * 0.5))
                outer_box = outer_box.cut(hole)
                
    elif shape_type == 'funnel':
        top_d = convert_to_mm(design_data.get('top_diameter', 100), units)
        bottom_d = convert_to_mm(design_data.get('bottom_diameter', 15), units)
        funnel_height = convert_to_mm(design_data.get('height', 80), units)
        print(f"Funnel: ⌀{top_d}mm → ⌀{bottom_d}mm, {funnel_height}mm", file=sys.stderr)
        outer_box = Part.makeCone(bottom_d/2, top_d/2, funnel_height)
        if wall_thickness > 0:
            inner = Part.makeCone(bottom_d/2 - wall_thickness/2, top_d/2 - wall_thickness, funnel_height - wall_thickness/2)
            outer_box = outer_box.cut(inner)
            
    elif shape_type == 'lid':
        lid_diameter = convert_to_mm(design_data.get('diameter', 80), units)
        lid_height = convert_to_mm(design_data.get('height', 15), units)
        has_thread = design_data.get('thread', False)
        print(f"Lid: ⌀{lid_diameter}mm x {lid_height}mm", file=sys.stderr)
        top = Part.makeCylinder(lid_diameter/2, wall_thickness * 2)
        rim = Part.makeCylinder(lid_diameter/2 - wall_thickness, lid_height)
        rim.translate(FreeCAD.Vector(0, 0, -lid_height + wall_thickness * 2))
        outer_box = top.fuse(rim)
        
    elif shape_type == 'loft':
        # Loft between multiple cross-sections for smooth transitions
        sections = design_data.get('sections', [])
        loft_height = convert_to_mm(design_data.get('height', 100), units)
        print(f"Loft: {len(sections)} sections, {loft_height}mm", file=sys.stderr)
        
        if len(sections) >= 2:
            wires = []
            for i, section in enumerate(sections):
                z = (i / (len(sections) - 1)) * loft_height
                shape = section.get('shape', 'circle')
                size = convert_to_mm(section.get('size', 50), units)
                
                if shape == 'circle':
                    wire = Part.Wire(Part.makeCircle(size/2, FreeCAD.Vector(0, 0, z)))
                elif shape == 'square':
                    points = [
                        FreeCAD.Vector(-size/2, -size/2, z),
                        FreeCAD.Vector(size/2, -size/2, z),
                        FreeCAD.Vector(size/2, size/2, z),
                        FreeCAD.Vector(-size/2, size/2, z),
                        FreeCAD.Vector(-size/2, -size/2, z)
                    ]
                    wire = Part.makePolygon(points)
                wires.append(wire)
            outer_box = Part.makeLoft(wires, True, False)
        else:
            # Fallback to cylinder
            outer_box = Part.makeCylinder(50, loft_height)
            
    elif shape_type == 'sweep':
        # Sweep a profile along a path
        profile_shape = design_data.get('profile_shape', 'circle')
        profile_size = convert_to_mm(design_data.get('profile_size', 10), units)
        path_type = design_data.get('path_type', 'helix')
        sweep_height = convert_to_mm(design_data.get('height', 100), units)
        sweep_radius = convert_to_mm(design_data.get('radius', 30), units)
        
        print(f"Sweep: {profile_shape} profile along {path_type} path", file=sys.stderr)
        
        # Create profile
        if profile_shape == 'circle':
            profile = Part.Wire(Part.makeCircle(profile_size/2, FreeCAD.Vector(sweep_radius, 0, 0)))
        else:
            # Square profile
            half = profile_size/2
            points = [
                FreeCAD.Vector(sweep_radius - half, -half, 0),
                FreeCAD.Vector(sweep_radius + half, -half, 0),
                FreeCAD.Vector(sweep_radius + half, half, 0),
                FreeCAD.Vector(sweep_radius - half, half, 0),
                FreeCAD.Vector(sweep_radius - half, -half, 0)
            ]
            profile = Part.makePolygon(points)
            
        # Create path
        if path_type == 'helix':
            pitch = design_data.get('pitch', sweep_height / 10)
            path = Part.makeHelix(pitch, sweep_height, sweep_radius)
        elif path_type == 'arc':
            path = Part.makeCircle(sweep_radius, FreeCAD.Vector(0, 0, 0))
        else:
            # Straight path
            path = Part.makeLine(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 0, sweep_height))
            
        outer_box = profile.makePipeShell([path], True, False)
        
    elif shape_type == 'revolve':
        # Revolve a 2D profile around an axis
        profile_points = design_data.get('profile_points', [])
        revolve_angle = design_data.get('angle', 360)
        
        print(f"Revolve: {len(profile_points)} points, {revolve_angle}°", file=sys.stderr)
        
        if not profile_points:
            # Default vase-like profile
            profile_points = [
                [0, 0], [30, 0], [40, 30], [35, 60], [40, 90], [30, 100], [0, 100]
            ]
        
        # Convert to FreeCAD vectors
        points = [FreeCAD.Vector(convert_to_mm(p[0], units), 0, convert_to_mm(p[1], units)) 
                  for p in profile_points]
        
        # Create profile wire
        profile = Part.makePolygon(points)
        face = Part.Face(profile)
        
        # Revolve around Z axis
        outer_box = face.revolve(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 0, 1), revolve_angle)
        
    elif shape_type == 'organic':
        # Create organic shape using metaballs/blobs
        blob_count = design_data.get('blob_count', 3)
        base_size = convert_to_mm(design_data.get('base_size', 50), units)
        
        print(f"Organic: {blob_count} blobs, base size {base_size}mm", file=sys.stderr)
        
        # Create multiple overlapping spheres
        blobs = []
        for i in range(blob_count):
            angle = (2 * math.pi * i) / blob_count
            radius = base_size / 2
            offset = base_size * 0.3
            x = offset * math.cos(angle)
            y = offset * math.sin(angle)
            
            blob = Part.makeSphere(radius)
            blob.translate(FreeCAD.Vector(x, y, 0))
            blobs.append(blob)
        
        # Fuse all blobs together
        outer_box = blobs[0]
        for blob in blobs[1:]:
            outer_box = outer_box.fuse(blob)
            
    elif shape_type == 'lattice':
        # Create lattice/mesh structure
        lattice_size = convert_to_mm(design_data.get('size', 50), units)
        cell_size = convert_to_mm(design_data.get('cell_size', 10), units)
        strut_thickness = convert_to_mm(design_data.get('strut_thickness', 2), units)
        
        print(f"Lattice: {lattice_size}mm³, cell {cell_size}mm, strut {strut_thickness}mm", file=sys.stderr)
        
        cells_per_side = int(lattice_size / cell_size)
        outer_box = Part.makeBox(0.1, 0.1, 0.1)  # Start with tiny box
        
        # Create struts
        for x in range(cells_per_side + 1):
            for y in range(cells_per_side + 1):
                for z in range(cells_per_side + 1):
                    # X-direction struts
                    if x < cells_per_side:
                        strut = Part.makeCylinder(strut_thickness/2, cell_size)
                        strut.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 1, 0), 90)
                        strut.translate(FreeCAD.Vector(x*cell_size, y*cell_size, z*cell_size))
                        outer_box = outer_box.fuse(strut)
                    # Y-direction struts  
                    if y < cells_per_side:
                        strut = Part.makeCylinder(strut_thickness/2, cell_size)
                        strut.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(1, 0, 0), 90)
                        strut.translate(FreeCAD.Vector(x*cell_size, y*cell_size, z*cell_size))
                        outer_box = outer_box.fuse(strut)
                    # Z-direction struts
                    if z < cells_per_side:
                        strut = Part.makeCylinder(strut_thickness/2, cell_size)
                        strut.translate(FreeCAD.Vector(x*cell_size, y*cell_size, z*cell_size))
                        outer_box = outer_box.fuse(strut)
    else:
        # Default box shape
        print(f"Box: {length}x{width}x{height} mm", file=sys.stderr)
        print(f"Wall thickness: {wall_thickness} mm", file=sys.stderr)
        outer_box = Part.makeBox(length, width, height)
    
    # Create hollow enclosure if wall thickness is specified
    if wall_thickness > 0 and wall_thickness < min(length, width, height) / 2:
        # Create inner cavity
        inner_length = length - 2 * wall_thickness
        inner_width = width - 2 * wall_thickness
        inner_height = height - wall_thickness  # Open top
        
        if inner_length > 0 and inner_width > 0 and inner_height > 0:
            inner_box = Part.makeBox(inner_length, inner_width, inner_height)
            inner_box.translate(FreeCAD.Vector(wall_thickness, wall_thickness, wall_thickness))
            
            # Subtract to create hollow enclosure
            outer_box = outer_box.cut(inner_box)
            print(f"Created hollow enclosure", file=sys.stderr)
    
    # Apply features
    features = design_data.get('features', [])
    
    # Add egg compartments if requested
    egg_features = [f for f in features if 'egg_compartment' in f or 'egg_storage' in f or 'egg_holder' in f]
    if egg_features:
        # Extract egg count (default 12)
        egg_count = 12
        for f in egg_features:
            if '_' in f:
                parts = f.split('_')
                for part in parts:
                    if part.isdigit():
                        egg_count = int(part)
                        break
        
        # Determine grid layout (optimize for most common egg carton sizes)
        if egg_count == 6:
            grid_rows, grid_cols = 2, 3
        elif egg_count == 12:
            grid_rows, grid_cols = 3, 4
        elif egg_count == 18:
            grid_rows, grid_cols = 3, 6
        elif egg_count == 24:
            grid_rows, grid_cols = 4, 6
        else:
            # Square-ish layout for other counts
            grid_cols = int(math.ceil(math.sqrt(egg_count)))
            grid_rows = int(math.ceil(egg_count / grid_cols))
        
        print(f"Creating egg storage for {egg_count} eggs ({grid_rows}x{grid_cols} grid)", file=sys.stderr)
        
        # Calculate compartment dimensions
        compartment_width = (length - wall_thickness * 2) / grid_cols
        compartment_depth = (width - wall_thickness * 2) / grid_rows
        
        # Egg dimensions (standard large egg ~ 57mm height, 43mm diameter)
        egg_diameter = min(compartment_width, compartment_depth) * 0.85
        egg_depth = min(height - wall_thickness, egg_diameter * 0.7)
        
        print(f"Compartment size: {compartment_width:.1f}x{compartment_depth:.1f}mm, egg: ⌀{egg_diameter:.1f}mm depth {egg_depth:.1f}mm", file=sys.stderr)
        
        # Create hemispherical depressions for each egg
        for row in range(grid_rows):
            for col in range(grid_cols):
                egg_num = row * grid_cols + col
                if egg_num >= egg_count:
                    break
                
                # Calculate center position of this compartment
                center_x = wall_thickness + compartment_width * (col + 0.5)
                center_y = wall_thickness + compartment_depth * (row + 0.5)
                center_z = height - egg_depth * 0.5  # Start from top
                
                try:
                    # Create hemispherical depression (partial sphere cut)
                    sphere_radius = egg_diameter / 2.2  # Slightly smaller than compartment
                    depression = Part.makeSphere(sphere_radius)
                    depression.translate(FreeCAD.Vector(center_x, center_y, center_z))
                    outer_box = outer_box.cut(depression)
                except Exception as e:
                    print(f"Warning: Failed to create egg compartment at ({row},{col}): {e}", file=sys.stderr)
        
        print(f"Added {min(egg_count, grid_rows * grid_cols)} egg compartments", file=sys.stderr)
        
        # Add divider ribs between compartments for structural support
        divider_thickness = max(1.5, wall_thickness * 0.5)
        divider_height = height - wall_thickness - egg_depth * 0.3
        
        # Horizontal dividers (between rows)
        for row in range(1, grid_rows):
            y_pos = wall_thickness + compartment_depth * row - divider_thickness / 2
            try:
                divider = Part.makeBox(length - wall_thickness * 2, divider_thickness, divider_height)
                divider.translate(FreeCAD.Vector(wall_thickness, y_pos, wall_thickness))
                outer_box = outer_box.fuse(divider)
            except Exception as e:
                print(f"Warning: Failed to create horizontal divider at row {row}: {e}", file=sys.stderr)
        
        # Vertical dividers (between columns)
        for col in range(1, grid_cols):
            x_pos = wall_thickness + compartment_width * col - divider_thickness / 2
            try:
                divider = Part.makeBox(divider_thickness, width - wall_thickness * 2, divider_height)
                divider.translate(FreeCAD.Vector(x_pos, wall_thickness, wall_thickness))
                outer_box = outer_box.fuse(divider)
            except Exception as e:
                print(f"Warning: Failed to create vertical divider at column {col}: {e}", file=sys.stderr)
        
        print(f"Added {grid_rows - 1} horizontal and {grid_cols - 1} vertical dividers", file=sys.stderr)
    
    # Apply fillets if requested
    if 'fillet' in features or 'rounded_edges' in features or 'rounded' in features:
        fillet_radius = min(3.0, wall_thickness * 0.8) if wall_thickness > 0 else 2.0
        try:
            # Fillet all vertical edges for better appearance
            edges_to_fillet = []
            for edge in outer_box.Edges:
                # Find vertical edges (those with Z variation)
                bbox = edge.BoundBox
                z_variation = abs(bbox.ZMax - bbox.ZMin)
                # If edge is mostly vertical and near outer surface
                if z_variation > height * 0.8:
                    edges_to_fillet.append(edge)
            
            if edges_to_fillet:
                outer_box = outer_box.makeFillet(fillet_radius, edges_to_fillet)
                print(f"Applied {fillet_radius}mm fillets to {len(edges_to_fillet)} vertical edges", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Fillet operation failed: {e}", file=sys.stderr)
    
    # Add mounting holes
    mounting_holes = design_data.get('mounting_holes', {})
    if mounting_holes or 'screw_holes' in features or 'mounting_holes' in features:
        hole_diameter = mounting_holes.get('diameter', 3.0) if mounting_holes else 3.0
        hole_diameter_mm = convert_to_mm(hole_diameter, units)
        hole_radius = hole_diameter_mm / 2
        hole_count = mounting_holes.get('count', 4) if mounting_holes else 4
        
        # Create holes at corners
        offset = max(10.0, hole_radius * 3)
        
        hole_positions = [
            (offset, offset),
            (length - offset, offset),
            (offset, width - offset),
            (length - offset, width - offset)
        ][:hole_count]
        
        for x, y in hole_positions:
            try:
                hole = Part.makeCylinder(hole_radius, height)
                hole.translate(FreeCAD.Vector(x, y, 0))
                outer_box = outer_box.cut(hole)
            except Exception as e:
                print(f"Warning: Failed to create hole at ({x}, {y}): {e}", file=sys.stderr)
        
        print(f"Added {len(hole_positions)} mounting holes (⌀{hole_diameter_mm}mm)", file=sys.stderr)
    
    # Add ventilation holes if requested
    if 'ventilation_holes' in features or 'ventilation' in features or 'vent_holes' in features or 'vents' in features:
        vent_diameter = 4.0  # mm
        vent_radius = vent_diameter / 2
        vent_spacing = 10.0  # mm between holes (increased for better visibility)
        
        # Create ventilation pattern on the front face (Y-normal)
        vent_start_x = length * 0.15
        vent_end_x = length * 0.85
        vent_start_z = height * 0.3
        vent_end_z = height * 0.7
        
        # Create grid pattern
        vent_count = 0
        z = vent_start_z
        while z <= vent_end_z:
            x = vent_start_x
            while x <= vent_end_x:
                try:
                    # Create hole through the front wall
                    vent_hole = Part.makeCylinder(vent_radius, wall_thickness * 1.5)
                    vent_hole.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(1, 0, 0), 90)
                    vent_hole.translate(FreeCAD.Vector(x, -0.1, z))
                    outer_box = outer_box.cut(vent_hole)
                    vent_count += 1
                except Exception as e:
                    print(f"Warning: Failed to create vent hole at ({x}, {z}): {e}", file=sys.stderr)
                x += vent_spacing
            z += vent_spacing
        
        print(f"Added {vent_count} ventilation holes (⌀{vent_diameter}mm) in grid pattern", file=sys.stderr)
    
    # Add handle/grip features
    handle_features = [f for f in features if 'handle' in f or 'grip' in f or 'hold' in f]
    if handle_features:
        handle_type = 'side'  # default
        for f in handle_features:
            if 'top' in f:
                handle_type = 'top'
            elif 'side' in f:
                handle_type = 'side'
        
        handle_width = min(length, width) * 0.3
        handle_height = height * 0.2
        handle_thickness = max(8, wall_thickness * 2)
        
        if handle_type == 'top':
            # Arc handle on top
            try:
                handle_base_width = handle_width
                handle_base_height = handle_thickness
                handle_arc_height = height * 0.15
                
                # Create handle profile
                arc_points = []
                for i in range(20):
                    t = i / 19.0
                    x = handle_base_width * (t - 0.5)
                    z = handle_arc_height * math.sin(t * math.pi)
                    arc_points.append(FreeCAD.Vector(x, 0, z))
                
                handle_wire = Part.makePolygon(arc_points)
                handle_circle = Part.Wire([Part.Circle(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(0, 0, 1), handle_thickness/2).toShape()])
                handle = handle_wire.makePipeShell([handle_circle], True, False)
                handle.translate(FreeCAD.Vector(length/2, width/2, height))
                outer_box = outer_box.fuse(handle)
                print(f"Added arc handle on top ({handle_width:.1f}mm wide)", file=sys.stderr)
            except Exception as e:
                print(f"Warning: Failed to create top handle: {e}", file=sys.stderr)
        else:
            # Side grips (indentations)
            try:
                grip_depth = wall_thickness * 0.6
                grip_width = min(length, width) * 0.4
                grip_height = height * 0.5
                
                for side in ['left', 'right']:
                    if side == 'left':
                        center_y = 0
                        direction = FreeCAD.Vector(0, 1, 0)
                    else:
                        center_y = width
                        direction = FreeCAD.Vector(0, -1, 0)
                    
                    center_x = length / 2
                    center_z = height / 2
                    
                    # Create ellipsoid grip depression
                    grip_sphere = Part.makeSphere(grip_width/2)
                    grip_sphere.scale(grip_width/2, grip_depth, grip_height/2)
                    grip_sphere.translate(FreeCAD.Vector(center_x, center_y, center_z))
                    outer_box = outer_box.cut(grip_sphere)
                
                print(f"Added ergonomic side grips ({grip_width:.1f}mm wide)", file=sys.stderr)
            except Exception as e:
                print(f"Warning: Failed to create side grips: {e}", file=sys.stderr)
    
    # Add lid/cover features
    lid_features = [f for f in features if 'lid' in f or 'cover' in f or 'cap' in f]
    if lid_features and shape_type == 'box':
        try:
            lid_lip_height = min(10, height * 0.15)
            lid_lip_thickness = max(1.5, wall_thickness * 0.5)
            
            # Create inner lip for lid to rest on
            lip_outer = Part.makeBox(
                length - wall_thickness * 2 + lid_lip_thickness * 2,
                width - wall_thickness * 2 + lid_lip_thickness * 2,
                lid_lip_height
            )
            lip_outer.translate(FreeCAD.Vector(
                wall_thickness - lid_lip_thickness,
                wall_thickness - lid_lip_thickness,
                height - lid_lip_height
            ))
            
            lip_inner = Part.makeBox(
                length - wall_thickness * 2 - lid_lip_thickness * 2,
                width - wall_thickness * 2 - lid_lip_thickness * 2,
                lid_lip_height + 1
            )
            lip_inner.translate(FreeCAD.Vector(
                wall_thickness + lid_lip_thickness,
                wall_thickness + lid_lip_thickness,
                height - lid_lip_height - 0.5
            ))
            
            lid_lip = lip_outer.cut(lip_inner)
            outer_box = outer_box.fuse(lid_lip)
            print(f"Added lid retention lip ({lid_lip_height:.1f}mm high)", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create lid lip: {e}", file=sys.stderr)
    
    # Add compartment dividers (generic, not egg-specific)
    divider_features = [f for f in features if 'divider' in f or 'compartment' in f and 'egg' not in f or 'section' in f]
    if divider_features and shape_type == 'box':
        try:
            # Extract number of compartments
            num_compartments = 2
            for f in divider_features:
                if '_' in f:
                    parts = f.split('_')
                    for part in parts:
                        if part.isdigit():
                            num_compartments = int(part)
                            break
            
            divider_thickness = max(2, wall_thickness * 0.8)
            divider_height = height - wall_thickness * 2
            
            # Create evenly spaced dividers along length
            compartment_width = length / num_compartments
            for i in range(1, num_compartments):
                x_pos = compartment_width * i - divider_thickness / 2
                divider = Part.makeBox(divider_thickness, width - wall_thickness * 2, divider_height)
                divider.translate(FreeCAD.Vector(x_pos, wall_thickness, wall_thickness))
                outer_box = outer_box.fuse(divider)
            
            print(f"Added {num_compartments - 1} dividers creating {num_compartments} compartments", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create dividers: {e}", file=sys.stderr)
    
    # Add ribs/reinforcement
    rib_features = [f for f in features if 'rib' in f or 'reinforcement' in f or 'strengthen' in f]
    if rib_features and shape_type == 'box':
        try:
            rib_thickness = max(1.5, wall_thickness * 0.6)
            rib_height = (height - wall_thickness * 2) * 0.7
            rib_spacing = max(30, length * 0.15)
            
            # Add ribs along the bottom interior for strength
            num_ribs = int((length - wall_thickness * 4) / rib_spacing)
            rib_count = 0
            
            for i in range(1, num_ribs + 1):
                x_pos = wall_thickness * 2 + rib_spacing * i
                if x_pos < length - wall_thickness * 2:
                    # Longitudinal rib
                    rib = Part.makeBox(rib_thickness, width - wall_thickness * 2, rib_height)
                    rib.translate(FreeCAD.Vector(x_pos, wall_thickness, wall_thickness))
                    outer_box = outer_box.fuse(rib)
                    rib_count += 1
            
            print(f"Added {rib_count} reinforcement ribs ({rib_thickness}mm thick)", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create ribs: {e}", file=sys.stderr)
    
    # Add grip texture/pattern
    texture_features = [f for f in features if 'texture' in f or 'pattern' in f or 'knurl' in f or 'grip_pattern' in f]
    if texture_features:
        try:
            # Create small cylindrical bumps for grip texture
            bump_diameter = 2.0
            bump_height = 1.0
            bump_spacing = 4.0
            
            # Apply to front face
            texture_start_x = length * 0.1
            texture_end_x = length * 0.9
            texture_start_z = height * 0.2
            texture_end_z = height * 0.8
            
            bump_count = 0
            z = texture_start_z
            row = 0
            while z <= texture_end_z:
                x = texture_start_x
                # Offset every other row for hexagonal pattern
                if row % 2 == 1:
                    x += bump_spacing / 2
                
                while x <= texture_end_x:
                    try:
                        bump = Part.makeCylinder(bump_diameter/2, bump_height)
                        bump.rotate(FreeCAD.Vector(0, 0, 0), FreeCAD.Vector(1, 0, 0), 90)
                        bump.translate(FreeCAD.Vector(x, -bump_height + 0.1, z))
                        outer_box = outer_box.fuse(bump)
                        bump_count += 1
                    except:
                        pass
                    x += bump_spacing
                z += bump_spacing * 0.866  # Hex pattern spacing
                row += 1
            
            print(f"Added grip texture with {bump_count} bumps (hexagonal pattern)", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create grip texture: {e}", file=sys.stderr)
    
    # Add chamfers (beveled edges alternative to fillets)
    chamfer_features = [f for f in features if 'chamfer' in f or 'bevel' in f]
    if chamfer_features and 'fillet' not in features:
        try:
            chamfer_distance = min(2.0, wall_thickness * 0.7) if wall_thickness > 0 else 1.5
            edges_to_chamfer = []
            
            for edge in outer_box.Edges:
                bbox = edge.BoundBox
                z_variation = abs(bbox.ZMax - bbox.ZMin)
                if z_variation > height * 0.8:
                    edges_to_chamfer.append(edge)
            
            if edges_to_chamfer:
                outer_box = outer_box.makeChamfer(chamfer_distance, edges_to_chamfer)
                print(f"Applied {chamfer_distance}mm chamfers to {len(edges_to_chamfer)} edges", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Chamfer operation failed: {e}", file=sys.stderr)
    
    # Add drainage holes (bottom holes for water drainage)
    drainage_features = [f for f in features if 'drain' in f or 'water_drain' in f or 'drainage_hole' in f]
    if drainage_features:
        try:
            drain_diameter = 3.0
            drain_radius = drain_diameter / 2
            num_drains = 4
            
            drain_positions = [
                (length * 0.25, width * 0.25),
                (length * 0.75, width * 0.25),
                (length * 0.25, width * 0.75),
                (length * 0.75, width * 0.75)
            ]
            
            for x, y in drain_positions:
                drain_hole = Part.makeCylinder(drain_radius, wall_thickness * 1.5)
                drain_hole.translate(FreeCAD.Vector(x, y, -0.1))
                outer_box = outer_box.cut(drain_hole)
            
            print(f"Added {num_drains} drainage holes (⌀{drain_diameter}mm) in bottom", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create drainage holes: {e}", file=sys.stderr)
    
    # Add snap-fit features (clips for assembly)
    snap_features = [f for f in features if 'snap' in f or 'clip' in f or 'snap_fit' in f]
    if snap_features and shape_type == 'box':
        try:
            # Create cantilever snap clips on sides
            clip_length = 10
            clip_width = 5
            clip_thickness = 2
            clip_protrusion = 1.5
            
            num_clips = 2
            clip_spacing = width / (num_clips + 1)
            
            for i in range(1, num_clips + 1):
                y_pos = clip_spacing * i
                
                # Clip base
                clip_base = Part.makeBox(clip_thickness, clip_width, clip_length)
                clip_base.translate(FreeCAD.Vector(length, y_pos - clip_width/2, height * 0.5))
                outer_box = outer_box.fuse(clip_base)
                
                # Clip catch (small protrusion)
                clip_catch = Part.makeBox(clip_protrusion, clip_width * 0.7, clip_thickness)
                clip_catch.translate(FreeCAD.Vector(length + clip_thickness, y_pos - clip_width*0.35, height * 0.5 + clip_length - clip_thickness))
                outer_box = outer_box.fuse(clip_catch)
            
            print(f"Added {num_clips} snap-fit clips on side", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create snap-fit features: {e}", file=sys.stderr)
    
    # Add label/text embossing area
    label_features = [f for f in features if 'label' in f or 'text_area' in f or 'emboss' in f]
    if label_features:
        try:
            label_width = min(length, width) * 0.6
            label_height = height * 0.15
            label_depth = 0.5
            
            # Create recessed area for label on front
            label_recess = Part.makeBox(label_width, label_depth, label_height)
            label_recess.translate(FreeCAD.Vector(
                length * 0.5 - label_width/2,
                -label_depth + 0.1,
                height * 0.75
            ))
            outer_box = outer_box.cut(label_recess)
            print(f"Added label area ({label_width:.1f}x{label_height:.1f}mm) on front", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create label area: {e}", file=sys.stderr)
    
    # Add feet/standoffs (raised supports on bottom)
    feet_features = [f for f in features if 'feet' in f or 'standoff' in f or 'rubber_feet' in f]
    if feet_features:
        try:
            foot_diameter = 8
            foot_height = 3
            foot_radius = foot_diameter / 2
            
            foot_positions = [
                (length * 0.1, width * 0.1),
                (length * 0.9, width * 0.1),
                (length * 0.1, width * 0.9),
                (length * 0.9, width * 0.9)
            ]
            
            for x, y in foot_positions:
                foot = Part.makeCylinder(foot_radius, foot_height)
                foot.translate(FreeCAD.Vector(x, y, -foot_height))
                outer_box = outer_box.fuse(foot)
            
            print(f"Added 4 feet (⌀{foot_diameter}mm x {foot_height}mm tall)", file=sys.stderr)
        except Exception as e:
            print(f"Warning: Failed to create feet: {e}", file=sys.stderr)
    
    # Add custom cutouts (LED holes, buttons, USB ports, etc.)
    cutouts = design_data.get('cutouts', [])
    if cutouts:
        for cutout in cutouts:
            try:
                cutout_type = cutout.get('type', 'generic')
                position = cutout.get('position', 'front')
                
                # Determine cutout location
                if position == 'front':
                    base_pos = FreeCAD.Vector(length * 0.5, -0.1, height * 0.5)
                    rotation_axis = FreeCAD.Vector(1, 0, 0)
                    rotation_angle = 90
                    depth = wall_thickness * 1.5
                elif position == 'back':
                    base_pos = FreeCAD.Vector(length * 0.5, width + 0.1, height * 0.5)
                    rotation_axis = FreeCAD.Vector(1, 0, 0)
                    rotation_angle = 90
                    depth = wall_thickness * 1.5
                elif position == 'top':
                    base_pos = FreeCAD.Vector(length * 0.5, width * 0.5, height + 0.1)
                    rotation_axis = FreeCAD.Vector(0, 0, 1)
                    rotation_angle = 0
                    depth = wall_thickness * 1.5
                elif position == 'side':
                    base_pos = FreeCAD.Vector(-0.1, width * 0.5, height * 0.5)
                    rotation_axis = FreeCAD.Vector(0, 1, 0)
                    rotation_angle = 90
                    depth = wall_thickness * 1.5
                else:
                    continue  # Unknown position
                
                # Create cutout shape
                if 'diameter' in cutout:
                    # Circular cutout (LED, button, etc.)
                    diameter_raw = cutout.get('diameter')
                    
                    if diameter_raw is None or diameter_raw <= 0:
                        print(f"Warning: {cutout_type} cutout has invalid diameter ({diameter_raw}), skipping", file=sys.stderr)
                        continue
                    
                    diameter = convert_to_mm(diameter_raw, units)
                    radius = diameter / 2
                    hole = Part.makeCylinder(radius, depth)
                    if rotation_angle != 0:
                        hole.rotate(FreeCAD.Vector(0, 0, 0), rotation_axis, rotation_angle)
                    hole.translate(base_pos)
                    outer_box = outer_box.cut(hole)
                    print(f"Added {cutout_type} cutout (⌀{diameter}mm) on {position}", file=sys.stderr)
                elif 'width' in cutout and 'height' in cutout:
                    # Rectangular cutout (USB, power, etc.)
                    cutout_width_raw = cutout.get('width')
                    cutout_height_raw = cutout.get('height')
                    
                    # Validate dimensions are not None
                    if cutout_width_raw is None or cutout_height_raw is None:
                        print(f"Warning: {cutout_type} cutout has missing dimensions (width={cutout_width_raw}, height={cutout_height_raw}), skipping", file=sys.stderr)
                        continue
                    
                    cutout_width = convert_to_mm(cutout_width_raw, units)
                    cutout_height = convert_to_mm(cutout_height_raw, units)
                    
                    # Ensure positive dimensions
                    if cutout_width <= 0 or cutout_height <= 0:
                        print(f"Warning: {cutout_type} cutout has invalid dimensions ({cutout_width}x{cutout_height}mm), skipping", file=sys.stderr)
                        continue
                    
                    rect_hole = Part.makeBox(cutout_width, depth, cutout_height)
                    rect_hole.translate(FreeCAD.Vector(-cutout_width/2, 0, -cutout_height/2))
                    if rotation_angle != 0:
                        rect_hole.rotate(FreeCAD.Vector(0, 0, 0), rotation_axis, rotation_angle)
                    rect_hole.translate(base_pos)
                    outer_box = outer_box.cut(rect_hole)
                    print(f"Added {cutout_type} cutout ({cutout_width}x{cutout_height}mm) on {position}", file=sys.stderr)
            except Exception as e:
                print(f"Warning: Failed to create {cutout.get('type', 'unknown')} cutout: {e}", file=sys.stderr)
    
    # Validate geometry for 3D printing
    print("\\n=== 3D PRINT ANALYSIS ===", file=sys.stderr)
    is_manifold = check_manifold_geometry(outer_box)
    if is_manifold:
        print("✓ Geometry is manifold (watertight) - ready for slicing", file=sys.stderr)
    else:
        print("⚠ Geometry may have issues - check in slicer software", file=sys.stderr)
    
    # Detect overhangs that need support
    overhangs = detect_overhangs(outer_box, angle_threshold=50)
    if overhangs:
        total_overhang_area = sum(o['area'] for o in overhangs)
        print(f"⚠ Detected {len(overhangs)} overhanging surfaces (total {total_overhang_area:.1f}mm²)", file=sys.stderr)
        print(f"  Recommendation: Enable supports in slicer (support angle: 50°)", file=sys.stderr)
    else:
        print("✓ No significant overhangs detected - can print without supports", file=sys.stderr)
    
    # Calculate and display print settings
    print_settings = calculate_print_settings(design_data)
    print(f"\\n=== RECOMMENDED PRINT SETTINGS ===", file=sys.stderr)
    print(f"Material: {print_settings['material']}", file=sys.stderr)
    print(f"Layer Height: {print_settings['layer_height']}mm", file=sys.stderr)
    print(f"Infill: {print_settings['infill_percentage']}% ({print_settings['infill_pattern']})", file=sys.stderr)
    print(f"Walls: {print_settings['wall_line_count']} perimeters", file=sys.stderr)
    print(f"Print Speed: {print_settings['print_speed']}mm/s", file=sys.stderr)
    print(f"Bed Adhesion: {print_settings['adhesion_type']}", file=sys.stderr)
    print(f"Supports: {'Required' if overhangs else 'Not needed'}", file=sys.stderr)
    print(f"\\nEstimated Print Time: ~{print_settings['estimated_time_hours']} hours", file=sys.stderr)
    print(f"Estimated Material: ~{print_settings['estimated_material_g']}g", file=sys.stderr)
    print(f"=== END ANALYSIS ===\\n", file=sys.stderr)
    
    # Validate geometry for 3D printing
    print("\n=== 3D PRINT ANALYSIS ===", file=sys.stderr)
    is_manifold = check_manifold_geometry(outer_box)
    if is_manifold:
        print("✓ Geometry is manifold (watertight) - ready for slicing", file=sys.stderr)
    else:
        print("⚠ Geometry may have issues - check in slicer software", file=sys.stderr)
    
    # Detect overhangs that need support
    overhangs = detect_overhangs(outer_box, angle_threshold=50)
    if overhangs:
        total_overhang_area = sum(o['area'] for o in overhangs)
        print(f"⚠ Detected {len(overhangs)} overhanging surfaces (total {total_overhang_area:.1f}mm²)", file=sys.stderr)
        print(f"  Recommendation: Enable supports in slicer (support angle: 50°)", file=sys.stderr)
    else:
        print("✓ No significant overhangs detected - can print without supports", file=sys.stderr)
    
    # Calculate and display print settings
    print_settings = calculate_print_settings(design_data)
    print(f"\n=== RECOMMENDED PRINT SETTINGS ===", file=sys.stderr)
    print(f"Material: {print_settings['material']}", file=sys.stderr)
    print(f"Layer Height: {print_settings['layer_height']}mm", file=sys.stderr)
    print(f"Infill: {print_settings['infill_percentage']}% ({print_settings['infill_pattern']})", file=sys.stderr)
    print(f"Walls: {print_settings['wall_line_count']} perimeters", file=sys.stderr)
    print(f"Print Speed: {print_settings['print_speed']}mm/s", file=sys.stderr)
    print(f"Bed Adhesion: {print_settings['adhesion_type']}", file=sys.stderr)
    print(f"Supports: {'Required' if overhangs else 'Not needed'}", file=sys.stderr)
    print(f"\nEstimated Print Time: ~{print_settings['estimated_time_hours']} hours", file=sys.stderr)
    print(f"Estimated Material: ~{print_settings['estimated_material_g']}g", file=sys.stderr)
    print(f"=== END ANALYSIS ===\n", file=sys.stderr)
    
    # Add to document
    part_obj = doc.addObject("Part::Feature", product_type.title())
    part_obj.Shape = outer_box
    
    # Export files
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    step_file = output_dir / f"{build_id}.step"
    stl_file = output_dir / f"{build_id}.stl"
    
    # Export STEP
    try:
        Part.export([part_obj], str(step_file))
        print(f"Exported STEP: {step_file.name}", file=sys.stderr)
    except Exception as e:
        print(f"Error exporting STEP: {e}", file=sys.stderr)
    
    # Export STL with optimized quality for 3D printing
    try:
        import MeshPart  # type: ignore
        # Optimized mesh for 3D printing:
        # - Fine enough for smooth curves
        # - Not so fine that slicer software slows down
        # - Linear deflection 0.1mm is good balance
        mesh = MeshPart.meshFromShape(
            outer_box, 
            LinearDeflection=0.1,   # 0.1mm deviation max - good for FDM printing
            AngularDeflection=0.523599,  # 30 degrees - sufficient for most slicers
            Relative=False
        )
        mesh.write(str(stl_file))
        
        # Calculate mesh statistics
        num_triangles = len(mesh.Facets)
        file_size_kb = stl_file.stat().st_size / 1024 if stl_file.exists() else 0
        
        print(f"Exported STL: {stl_file.name}", file=sys.stderr)
        print(f"  Triangles: {num_triangles:,}", file=sys.stderr)
        print(f"  File size: {file_size_kb:.1f} KB", file=sys.stderr)
        print(f"  Ready for slicing software (Cura, PrusaSlicer, etc.)", file=sys.stderr)
    except Exception as e:
        print(f"Error exporting STL: {e}", file=sys.stderr)
        # Fallback: try alternative method
        try:
            mesh_obj = doc.addObject("Mesh::Feature", "Mesh")
            # Higher quality tessellation
            mesh_obj.Mesh = Mesh.Mesh(outer_box.tessellate(0.05))
            Mesh.export([mesh_obj], str(stl_file))
            print(f"Exported STL (alternative method): {stl_file.name}", file=sys.stderr)
        except Exception as e2:
            print(f"Error with alternative STL export: {e2}", file=sys.stderr)
    
    # Export OBJ file (for visualization)
    obj_file = output_dir / f"{build_id}.obj"
    try:
        export_obj_file(outer_box, obj_file)
        print(f"Exported OBJ: {obj_file.name}", file=sys.stderr)
    except Exception as e:
        print(f"Error exporting OBJ: {e}", file=sys.stderr)
    
    # Close document without saving
    FreeCAD.closeDocument(doc.Name)
    
    return [str(step_file.name), str(stl_file.name), str(obj_file.name)]


def main():
    if len(sys.argv) < 2:
        print("Error: build_id required", file=sys.stderr)
        sys.exit(1)
    
    build_id = sys.argv[1]
    
    # Check if this is component generation mode
    component_mode = '--components' in sys.argv
    component_file_path = None
    if component_mode and len(sys.argv) >= 4:
        component_file_path = sys.argv[3]  # Path to component JSON file
    
    # Read design JSON from stdin
    try:
        design_json = sys.stdin.read()
        design_data = json.loads(design_json)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON input: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Determine output directory
    script_dir = Path(__file__).parent
    output_dir = script_dir.parent.parent / 'exports' / 'cad'
    
    try:
        if component_mode and component_file_path:
            # Generate only PCB component 3D models
            component_file = Path(component_file_path)
            if not component_file.exists():
                raise Exception(f"Component file not found: {component_file}")
            
            component_3d_files = generate_pcb_component_models(design_data, component_file, output_dir, build_id)
            
            result = {
                'success': True,
                'component_models': component_3d_files,
                'files': component_3d_files,
                'build_id': build_id
            }
            print(json.dumps(result))
        elif design_data.get('use_design_language') and design_data.get('operations'):
            # Design Language mode - execute sequential operations
            print("Using CAD Design Language mode", file=sys.stderr)
            from design_language import execute_design_language
            files = execute_design_language(design_data, build_id, output_dir)
            
            result = {
                'success': True,
                'files': files,
                'design_language': True,
                'operations_count': len(design_data.get('operations', [])),
                'build_id': build_id
            }
            print(json.dumps(result))
        else:
            # Normal CAD generation mode
            files = generate_cad_model(design_data, output_dir, build_id)
            
            # If PCB components exist, generate component models
            component_3d_files = []
            if design_data.get('pcb_required') and design_data.get('pcb_details'):
                component_file = script_dir.parent.parent / 'exports' / 'pcb' / f"{build_id}_components.json"
                if component_file.exists():
                    component_3d_files = generate_pcb_component_models(design_data, component_file, output_dir, build_id)
            
            # Output result as JSON
            result = {
                'success': True,
                'files': files,
                'component_models': component_3d_files,
                'build_id': build_id
            }
            print(json.dumps(result))
        
    except Exception as e:
        print(f"Error: CAD generation failed: {e}", file=sys.stderr)
        sys.exit(1)


def generate_pcb_component_models(design_data, component_file, output_dir, build_id):
    """Generate accurate 3D models for PCB components using KiCad 3D libraries"""
    if not FREECAD_AVAILABLE:
        return []
    
    import json
    try:
        import ImportPart
        IMPORT_PART_AVAILABLE = True
    except ImportError:
        IMPORT_PART_AVAILABLE = False
        print("Warning: ImportPart module not available, will use fallback component geometry", file=sys.stderr)
    
    # KiCad 3D model library path
    KICAD_3D_PATH = Path(__file__).parent.parent.parent / 'kicad_libs' / '3dmodels'
    
    print(f"KiCad 3D library path: {KICAD_3D_PATH}", file=sys.stderr)
    print(f"Library exists: {KICAD_3D_PATH.exists()}", file=sys.stderr)
    
    # Load component positions
    with open(component_file, 'r') as f:
        component_data = json.load(f)
    
    components = component_data.get('components', [])
    if not components:
        return []
    
    doc = FreeCAD.newDocument(f"PCB_Components_{build_id}")
    component_models = []
    
    # Component type to 3D model file mapping
    model_library = {
        'resistor': KICAD_3D_PATH / 'Resistor_SMD.3dshapes' / 'R_0805_2012Metric.step',
        'capacitor': KICAD_3D_PATH / 'Capacitor_SMD.3dshapes' / 'C_0805_2012Metric.step',
        'led': KICAD_3D_PATH / 'LED_SMD.3dshapes' / 'LED_0805_2012Metric.step',
        'diode': KICAD_3D_PATH / 'Diode_SMD.3dshapes' / 'D_SOD-323.step',
        'transistor': KICAD_3D_PATH / 'Package_TO_SOT_SMD.3dshapes' / 'SOT-23.step',
        'ic': KICAD_3D_PATH / 'Package_SO.3dshapes' / 'SOIC-8_3.9x4.9mm_P1.27mm.step',
        'microcontroller': KICAD_3D_PATH / 'Package_QFP.3dshapes' / 'TQFP-32_7x7mm_P0.8mm.step',
        'connector': KICAD_3D_PATH / 'Connector_PinHeader_2.54mm.3dshapes' / 'PinHeader_1x02_P2.54mm_Vertical.step',
        'switch': KICAD_3D_PATH / 'Button_Switch_SMD.3dshapes' / 'SW_SPST_PTS645Sx43SMTR92.step',
        'crystal': KICAD_3D_PATH / 'Crystal.3dshapes' / 'Crystal_SMD_3225-4Pin_3.2x2.5mm.step',
        'inductor': KICAD_3D_PATH / 'Inductor_SMD.3dshapes' / 'L_0805_2012Metric.step',
    }
    
    for idx, comp in enumerate(components):
        comp_type = comp['type']
        ref = comp['reference']
        pos = comp['position']
        
        # Get 3D model file for this component type
        model_file = model_library.get(comp_type)
        
        if model_file and model_file.exists() and IMPORT_PART_AVAILABLE:
            try:
                print(f"Loading 3D model: {model_file}", file=sys.stderr)
                
                # Import STEP file using Import module
                import Import
                # Import into a temporary document first
                temp_doc = FreeCAD.newDocument("temp")
                Import.insert(str(model_file), temp_doc.Name)
                
                # Get all imported objects
                imported_objects = temp_doc.Objects
                
                if imported_objects:
                    # Combine all shapes into one compound
                    shapes = [obj.Shape for obj in imported_objects if hasattr(obj, 'Shape')]
                    
                    if shapes:
                        # Create compound shape
                        if len(shapes) == 1:
                            compound_shape = shapes[0]
                        else:
                            compound_shape = Part.makeCompound(shapes)
                        
                        # Create feature in main document
                        obj = doc.addObject("Part::Feature", f"{ref}_{comp_type}")
                        obj.Shape = compound_shape
                        
                        # Position the component
                        obj.Placement.Base = FreeCAD.Vector(pos['x'], pos['y'], 0)
                        
                        print(f"✓ Loaded 3D model for {ref} ({comp_type})", file=sys.stderr)
                        
                        component_models.append({
                            'reference': ref,
                            'type': comp_type,
                            'position': pos,
                            'model_file': str(model_file.name)
                        })
                    else:
                        raise Exception("No valid shapes in imported file")
                else:
                    raise Exception("No objects imported from STEP file")
                
                # Close temporary document
                FreeCAD.closeDocument("temp")
                
            except Exception as e:
                print(f"✗ Failed to load 3D model for {ref}: {e}", file=sys.stderr)
                import traceback
                traceback.print_exc(file=sys.stderr)
                # Fallback to simple geometry
                shape = create_fallback_component(comp_type, pos)
                if shape:
                    obj = doc.addObject("Part::Feature", f"{ref}_{comp_type}")
                    obj.Shape = shape
                    obj.Placement.Base = FreeCAD.Vector(pos['x'], pos['y'], 0)
                    component_models.append({
                        'reference': ref,
                        'type': comp_type,
                        'position': pos,
                        'model_file': 'fallback'
                    })
        else:
            # Fallback to simple geometry if model not found or ImportPart unavailable
            if not IMPORT_PART_AVAILABLE:
                print(f"⚠️ Using fallback geometry for {ref} (ImportPart unavailable)", file=sys.stderr)
            elif model_file:
                print(f"✗ 3D model not found: {model_file}", file=sys.stderr)
            else:
                print(f"✗ No 3D model mapping for type: {comp_type}", file=sys.stderr)
            shape = create_fallback_component(comp_type, pos)
            if shape:
                obj = doc.addObject("Part::Feature", f"{ref}_{comp_type}")
                obj.Shape = shape
                obj.Placement.Base = FreeCAD.Vector(pos['x'], pos['y'], 0)
                component_models.append({
                    'reference': ref,
                    'type': comp_type,
                    'position': pos,
                    'model_file': 'fallback'
                })
    
    # Create PCB substrate
    board_size = component_data.get('board_size', {})
    pcb_width = board_size.get('width', 50)
    pcb_height = board_size.get('height', 50)
    pcb_thickness = 1.6  # Standard PCB thickness in mm
    
    pcb_board = Part.makeBox(pcb_width, pcb_height, pcb_thickness)
    pcb_board.translate(FreeCAD.Vector(0, 0, -pcb_thickness))
    pcb_obj = doc.addObject("Part::Feature", "PCB_Board")
    pcb_obj.Shape = pcb_board
    
    # Export as STEP file
    step_file = output_dir / f"{build_id}_pcb_components.step"
    Part.export(doc.Objects, str(step_file))
    print(f"Exported PCB components: {step_file.name}", file=sys.stderr)
    
    # Export as STL for 3D preview
    stl_file = output_dir / f"{build_id}_pcb_components.stl"
    Mesh.export(doc.Objects, str(stl_file))
    print(f"Exported PCB components STL: {stl_file.name}", file=sys.stderr)
    
    # Save component metadata
    component_meta_file = output_dir / f"{build_id}_component_meta.json"
    with open(component_meta_file, 'w') as f:
        json.dump({
            'components': component_models,
            'pcb_size': {'width': pcb_width, 'height': pcb_height, 'thickness': pcb_thickness}
        }, f, indent=2)
    
    FreeCAD.closeDocument(doc.Name)
    
    return [
        str(step_file.relative_to(output_dir.parent.parent)),
        str(stl_file.relative_to(output_dir.parent.parent)),
        str(component_meta_file.relative_to(output_dir.parent.parent))
    ]


def create_fallback_component(comp_type, pos):
    """Create simple box geometry as fallback when 3D model not available"""
    # Component dimensions based on standard packages
    dimensions = {
        'resistor': (2.0, 1.25, 0.6),  # 0805
        'capacitor': (2.0, 1.25, 0.6),
        'led': (2.0, 1.25, 0.8),
        'diode': (1.7, 1.25, 0.95),
        'transistor': (2.9, 1.3, 1.0),  # SOT-23
        'ic': (4.9, 3.9, 1.5),  # SOIC-8
        'microcontroller': (7.0, 7.0, 1.5),  # TQFP-32
        'connector': (5.0, 5.0, 3.0),
        'switch': (6.0, 6.0, 3.5),
        'crystal': (3.2, 2.5, 0.8),
        'inductor': (2.0, 1.25, 1.0),
    }
    
    dims = dimensions.get(comp_type, (2.0, 2.0, 1.0))
    w, h, d = dims
    
    shape = Part.makeBox(w, h, d)
    shape.translate(FreeCAD.Vector(pos['x'] - w/2, pos['y'] - h/2, 0))
    
    return shape


if __name__ == '__main__':
    main()
